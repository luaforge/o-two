// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2000
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.0.5

#ifndef ___apptest_h__
#define ___apptest_h__

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4000500L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace AppTest
{

class Testing;
typedef Testing* Testing_ptr;
typedef Testing* TestingRef;

extern OB::TypeCodeConst _tc_Testing;

} // End of namespace AppTest

void OBDuplicate(AppTest::Testing_ptr);
void OBRelease(AppTest::Testing_ptr);

void OBMarshal(AppTest::Testing_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(AppTest::Testing_ptr&, OB::InputStreamImpl*);

namespace AppTest
{

typedef OB::ObjVar< Testing > Testing_var;
typedef OB::ObjOut< Testing > Testing_out;

} // End of namespace AppTest

namespace OBStubImpl_AppTest
{

class Testing;
typedef Testing* Testing_ptr;

} // End of namespace OBStubImpl_AppTest

void OBDuplicate(OBStubImpl_AppTest::Testing_ptr);
void OBRelease(OBStubImpl_AppTest::Testing_ptr);

namespace OBStubImpl_AppTest
{

typedef OB::ObjVar< Testing > Testing_var;

} // End of namespace OBStubImpl_AppTest

//
// IDL:AppTest:1.0
//
namespace AppTest
{

//
// IDL:AppTest/Testing:1.0
//
class Testing : virtual public CORBA::Object
{
    Testing(const Testing&);
    void operator=(const Testing&);

    static const char* ids_[];

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    Testing() { }
    virtual ~Testing() { }

    typedef Testing_ptr _ptr_type;
    typedef Testing_var _var_type;

    static inline Testing_ptr
    _duplicate(Testing_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Testing_ptr
    _nil()
    {
        return 0;
    }

    static Testing_ptr _narrow(CORBA::Object_ptr);
    static Testing_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _OB_ids() const;
    static const char** _OB_staticIds();

    //
    // IDL:AppTest/Testing/say:1.0
    //
    void say(const char* text);
};

} // End of namespace AppTest

//
// IDL:AppTest:1.0
//
namespace OBStubImpl_AppTest
{

//
// IDL:AppTest/Testing:1.0
//
class Testing : virtual public OB::StubImplBase
{
    Testing(const Testing&);
    void operator=(const Testing&);

protected:

    Testing() { }

public:

    static inline Testing_ptr
    _duplicate(Testing_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Testing_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:AppTest/Testing/say:1.0
    //
    virtual void say(const char* text) = 0;
};

} // End of namespace OBStubImpl_AppTest

//
// IDL:AppTest:1.0
//
namespace OBMarshalStubImpl_AppTest
{

//
// IDL:AppTest/Testing:1.0
//
class Testing : virtual public OBStubImpl_AppTest::Testing,
                virtual public OB::MarshalStubImpl
{
    Testing(const Testing&);
    void operator=(const Testing&);

protected:

    Testing() { }
    friend class AppTest::Testing;

public:

    //
    // IDL:AppTest/Testing/say:1.0
    //
    virtual void say(const char* text);
};

} // End of namespace OBMarshalStubImpl_AppTest

//
// IDL:AppTest:1.0
//
namespace OBV_AppTest
{

} // End of namespace OBV_AppTest

//
// IDL:AppTest/Testing:1.0
//
namespace CORBA
{

inline void
release(AppTest::Testing_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(AppTest::Testing_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_AppTest::Testing_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_AppTest::Testing_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, AppTest::Testing_ptr*);
void operator<<=(CORBA::Any&, AppTest::Testing_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, AppTest::Testing_ptr&);

inline void
operator<<=(CORBA::Any_var& any, AppTest::Testing_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, AppTest::Testing_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, AppTest::Testing_ptr& val)
{
    return any.in() >>= val;
}

#endif
